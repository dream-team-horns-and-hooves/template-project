/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/builder/Builder.ts":
/*!*************************************!*\
  !*** ./src/core/builder/Builder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Builder: () => (/* binding */ Builder)\n/* harmony export */ });\n/* harmony import */ var _core_encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/encoder */ \"./src/core/encoder/index.ts\");\n/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../emitter */ \"./src/core/emitter/index.ts\");\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Scene */ \"./src/core/builder/Scene.ts\");\n\n\n\nconst config = {\n    '1080р': {\n        width: 1920,\n        height: 1080,\n        bitrate: 30e6,\n    },\n    '720р': {\n        width: 1280,\n        height: 720,\n        bitrate: 15e6,\n    },\n    '480р': {\n        width: 852,\n        height: 480,\n        bitrate: 6e6,\n    },\n};\nclass Builder {\n    encoder;\n    segments;\n    emitter;\n    scene;\n    config;\n    order;\n    position = 0;\n    finalPosition = 0;\n    frameCounter = 0;\n    totalCount = 0;\n    currentVideoId = null;\n    constructor(segments) {\n        this.segments = segments;\n        this.scene = new _Scene__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        this.encoder = new _core_encoder__WEBPACK_IMPORTED_MODULE_0__.Encoder();\n        this.emitter = new _emitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n    }\n    async configure(quality = '720р') {\n        this.config = config[quality];\n        this.order = this.segments.getDisplayOrder();\n        if (this.order.length === 0) {\n            this.finishWithoutResult();\n            return;\n        }\n        await this.encoder.initialize(this.config);\n        this.scene.createScene(this.config.width, this.config.height);\n        this.finalPosition = this.order.length;\n        this.build();\n    }\n    build() {\n        if (this.position === this.finalPosition) {\n            this.finish();\n            return;\n        }\n        this.currentVideoId = this.order[this.position];\n        this.position += 1;\n        this.process();\n    }\n    async process() {\n        const videoSegment = this.segments.getVideoSegmentById(this.currentVideoId);\n        const { totalChunks } = videoSegment.getSegmentInfo();\n        this.totalCount += totalChunks;\n        const engine = videoSegment.getEngine();\n        const chunks = engine.chunksWorker.chunks;\n        engine.frameChannel((frame) => {\n            this.createFrame(frame);\n            frame.close();\n        });\n        for (const chunk of chunks) {\n            engine.decoder.decode(chunk);\n        }\n        await engine.decoder.flush();\n        this.build();\n    }\n    createFrame(frame) {\n        const images = this.segments.getImageSegmentsByVideoId(this.currentVideoId);\n        const filter = this.segments.getFilterByVideoId(this.currentVideoId);\n        const scene = this.scene.drawOnScene({ frame, images, appliedFilter: filter });\n        const createdFrame = new VideoFrame(scene, {\n            timestamp: (this.frameCounter * 1e6) / 30,\n        });\n        let needsKeyFrame = this.frameCounter % 300 === 0;\n        this.encoder.encodeVideoFrame(createdFrame, {\n            keyFrame: needsKeyFrame,\n        });\n        this.frameCounter += 1;\n        createdFrame.close();\n    }\n    finishWithoutResult() {\n        console.log('finishWithoutResult');\n    }\n    async finish() {\n        const buffer = await this.encoder.finish();\n        this.emitter.emit('build-finish', buffer);\n    }\n    onFinish(callback) {\n        this.emitter.on('build-finish', callback);\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/builder/Builder.ts?");

/***/ }),

/***/ "./src/core/builder/Scene.ts":
/*!***********************************!*\
  !*** ./src/core/builder/Scene.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _engine_Preview_libs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/Preview/libs */ \"./src/core/engine/Preview/libs/index.ts\");\n\nclass Scene {\n    canvas;\n    ctx;\n    width;\n    height;\n    createScene(width, height) {\n        this.width = width;\n        this.height = height;\n        this.canvas = new OffscreenCanvas(this.width, this.height);\n        // @ts-ignore\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n    }\n    /**\n     * Рисует кадр, изображения (если есть) и применяет фильтр на canvas.\n     *\n     * @param {ObjectDraw} data - Данные для отрисовки, включая кадр, изображения и фильтр.\n     */\n    drawOnScene(data) {\n        const { frame, images, appliedFilter } = data;\n        this.clearScene();\n        this.drawFrame(frame);\n        this.drawImages(images);\n        this.applyFilter(appliedFilter);\n        return this.canvas;\n    }\n    /**\n     * Очищает сцену на canvas.\n     */\n    clearScene() {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n    /**\n     * Рисует кадр на canvas.\n     *\n     * @param {VideoFrame} frame - Кадр для отрисовки.\n     */\n    drawFrame(frame) {\n        const { width, height } = this.resizeImageToCanvasProportions(frame.displayWidth, frame.displayHeight);\n        const { x, y } = this.calculateCenteredImagePosition(width, height);\n        this.ctx.drawImage(frame, x, y, this.width, this.height);\n    }\n    /**\n     * Рисует изображения на canvas.\n     *\n     * @param {Array<{ position: ImagePosition; image: ImageBitmap }>} images - Массив изображений для отрисовки.\n     */\n    drawImages(images) {\n        if (images == null || images.length === 0)\n            return;\n        images.forEach(segment => {\n            const { image, position } = segment;\n            const [x, y] = (0,_engine_Preview_libs__WEBPACK_IMPORTED_MODULE_0__.getCoordinatesByPosition)(position, image.width, image.height, this.width, this.height);\n            this.ctx.drawImage(image, x, y, image.width, image.height);\n        });\n    }\n    /**\n     * Применяет фильтр к изображению на canvas.\n     *\n     * @param {ImageFilter} appliedFilter - Фильтр для применения.\n     */\n    applyFilter(appliedFilter) {\n        if (appliedFilter == null || appliedFilter === 'none')\n            return;\n        const imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n        const filterFn = (0,_engine_Preview_libs__WEBPACK_IMPORTED_MODULE_0__.getImageFilterFn)(appliedFilter);\n        filterFn(imageData);\n        this.ctx.putImageData(imageData, 0, 0);\n    }\n    /**\n     * Рассчитывает позицию изображения с центрированием на указанных размерах.\n     *\n     * @param {number} imageWidth - Ширина изображения.\n     * @param {number} imageHeight - Высота изображения.\n     * @returns {{ x: number, y: number }} - Объект с координатами x и y для центрирования изображения.\n     */\n    calculateCenteredImagePosition(imageWidth, imageHeight) {\n        let newWidth, newHeight;\n        if (imageWidth / this.width > imageHeight / this.height) {\n            newWidth = this.width;\n            newHeight = (imageHeight / imageWidth) * this.width;\n        }\n        else {\n            newWidth = (imageWidth / imageHeight) * this.height;\n            newHeight = this.height;\n        }\n        const x = (this.width - newWidth) / 2;\n        const y = (this.height - newHeight) / 2;\n        return { x, y };\n    }\n    /**\n     * Изменяет размеры изображения с сохранением пропорций в пределах максимальной ширины и высоты.\n     *\n     * @param {number} imageWidth - Исходная ширина изображения.\n     * @param {number} imageHeight - Исходная высота изображения.\n     * @returns {{ width: number, height: number }} - Объект с новой шириной и высотой изображения.\n     */\n    resizeImageToCanvasProportions(imageWidth, imageHeight) {\n        let width = imageWidth;\n        let height = imageHeight;\n        if (width > this.width || height > this.height) {\n            const aspectRatio = width / height;\n            if (width > this.width) {\n                width = this.width;\n                height = width / aspectRatio;\n            }\n            if (height > this.height) {\n                height = this.height;\n                width = height * aspectRatio;\n            }\n        }\n        return { width, height };\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/builder/Scene.ts?");

/***/ }),

/***/ "./src/core/builder/index.ts":
/*!***********************************!*\
  !*** ./src/core/builder/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Builder: () => (/* reexport safe */ _Builder__WEBPACK_IMPORTED_MODULE_0__.Builder)\n/* harmony export */ });\n/* harmony import */ var _Builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builder */ \"./src/core/builder/Builder.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/builder/index.ts?");

/***/ }),

/***/ "./src/core/decoder/AbstractMediaTrackDecoder.ts":
/*!*******************************************************!*\
  !*** ./src/core/decoder/AbstractMediaTrackDecoder.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractMediaTrackDecoder: () => (/* binding */ AbstractMediaTrackDecoder)\n/* harmony export */ });\n/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/emitter */ \"./src/core/emitter/index.ts\");\n\nconst DEFAULT_OUTPUT_FRAMES_SIZE = 100;\n/**\n * Абстрактный базовый класс для декодирования медиа-треков (аудио или видео).\n *\n * @abstract\n * @template T - Тип данных, представляющий декодированные кадры\n */\nclass AbstractMediaTrackDecoder {\n    /**\n     * Ссылка на объект Demuxer, который используется для разбора медиа-данных.\n     *\n     * @protected\n     * */\n    demuxer;\n    /**\n     * Экземпляр EventEmitter, используемый для создания и управления событиями в классе.\n     *\n     * @protected\n     */\n    emitter;\n    /**\n     * Статус компонента. Помогает запускать или не запускать те или иные действия по обработке медиа.\n     *\n     * @default 'pending'\n     * @protected\n     */\n    status = 'pending';\n    /**\n     * Размер выходной очереди фреймов. Определяет, сколько фреймов должно быть в очереди перед отправкой.\n     *\n     * @protected\n     */\n    outputFramesSize;\n    /**\n     * Счетчик общего количества samples (кадров) в медиа-дорожке.\n     *\n     * @protected\n     */\n    samplesCount = 0;\n    /**\n     * Счетчик количества декодированных фреймов\n     *\n     * @protected\n     */\n    decodedFramesCount = 0;\n    /**\n     * Массив для хранения декодированных фреймов\n     *\n     * @protected\n     */\n    frames = [];\n    /**\n     * callback-функция, используемая для отправки декодированных фреймов.\n     * @protected\n     */\n    // protected _sendFramesCallback: (result: DecodedFramesResult<T>) => void;\n    _sendFramesCallback;\n    /**\n     * Создает экземпляр AbstractMediaTrackDecoder.\n     *\n     * @param {Demuxer} demuxer - Demuxer, предоставляющий данные медиа-трека.\n     * @param {VideoDecoderOptions} options - Опции декодера видео.\n     */\n    constructor(demuxer, options = {}) {\n        this.emitter = new _core_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        const { outputFramesSize } = options;\n        this.demuxer = demuxer;\n        this.outputFramesSize = outputFramesSize ?? DEFAULT_OUTPUT_FRAMES_SIZE;\n        this.emitter.once('demuxing-complete', () => this.onDemuxComplete());\n        this.emitter.once('decoded-complete', () => this.onDecodeComplete());\n    }\n    /**\n     * Устанавливает callback для отправки декодированных кадров.\n     *\n     * @param {(result: DecodedFramesResult<T>) => void} callback - callback для отправки декодированных кадров.\n     */\n    onFrames(callback) {\n        console.log('SUB');\n        this._sendFramesCallback = callback;\n    }\n    /**\n     * Отправляет декодированные кадры по мере накопления или по завершении декодирования.\n     *\n     * @protected\n     */\n    // protected sendFrames() {\n    //     if (this._sendFramesCallback == null) return;\n    //     if (this.isFrameOutputIntervalReached || (this.isDecodingComplete && this.frames.length > 0)) {\n    //         this._sendFramesCallback({ value: this.frames, done: false });\n    //         this.frames.length = 0;\n    //     }\n    // }\n    sendFrames(frame) {\n        if (this._sendFramesCallback == null)\n            return;\n        this._sendFramesCallback(frame);\n        // if (this.isFrameOutputIntervalReached || (this.isDecodingComplete && this.frames.length > 0)) {\n        //     this.frames.length = 0;\n        // }\n    }\n    /**\n     * Обработчик завершения декодирования медиа-трека.\n     *\n     * @protected\n     */\n    onDecodeComplete() {\n        if (this.frames.length > 0)\n            this.frames.length = 0;\n        if (this._sendFramesCallback) {\n            this._sendFramesCallback({ done: true });\n        }\n    }\n    /**\n     * Проверяет, завершено ли декодирование всех samples медиа-трека.\n     *\n     * @protected\n     * @returns {boolean} `true`, если декодирование завершено, иначе `false`.\n     */\n    get isDecodingComplete() {\n        return this.decodedFramesCount === this.samplesCount;\n    }\n    /**\n     * Проверяет, достигнут ли интервал вывода кадров.\n     *\n     * @protected\n     * @returns {boolean} `true`, если интервал достигнут, иначе `false`.\n     */\n    get isFrameOutputIntervalReached() {\n        return this.decodedFramesCount % this.outputFramesSize === 0;\n    }\n    /**\n     * Устанавливает статус компонента-decoder-a.\n     *\n     * @param {Status} updatedStatus - Новый статус, который следует установить.\n     * @protected\n     */\n    setStatus(updatedStatus) {\n        this.status = updatedStatus;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/decoder/AbstractMediaTrackDecoder.ts?");

/***/ }),

/***/ "./src/core/decoder/AudioTrackDecoder.ts":
/*!***********************************************!*\
  !*** ./src/core/decoder/AudioTrackDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioTrackDecoder: () => (/* binding */ AudioTrackDecoder)\n/* harmony export */ });\n/* harmony import */ var _AbstractMediaTrackDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractMediaTrackDecoder */ \"./src/core/decoder/AbstractMediaTrackDecoder.ts\");\n\n/**\n * Класс `AudioTrackDecoder` представляет собой декодер аудио-треков.\n * Он наследует абстрактный класс `AbstractMediaTrackDecoder`.\n */\nclass AudioTrackDecoder extends _AbstractMediaTrackDecoder__WEBPACK_IMPORTED_MODULE_0__.AbstractMediaTrackDecoder {\n    decoder;\n    trackInfo;\n    chunks = [];\n    /**\n     * Создает экземпляр класса `AudioTrackDecoder`.\n     *\n     * @param {Demuxer} demuxer - Объект Demuxer, предоставляющий доступ к данным аудио-трека.\n     * @param {AudioDecoderOptions} options - Дополнительные опции для настройки декодера аудио.\n     */\n    constructor(demuxer, options = {}) {\n        super(demuxer, options);\n        this.trackInfo = this.demuxer.getAudioTrackInfo();\n        if (this.trackInfo) {\n            this.setStatus('ready-to-initialize');\n        }\n    }\n    /**\n     * Инициализирует декодер аудио.\n     *\n     * @returns {Promise<void>} Promise, разрешающийся после инициализации декодера.\n     * @public\n     */\n    async initializeDecoder() {\n        if (this.status !== 'ready-to-initialize')\n            return;\n        this.decoder = new AudioDecoder({\n            output: audioFrame => {\n                this.saveFrame(audioFrame);\n            },\n            error: err => {\n                console.error('Audio Decoder error : ', err);\n            },\n        });\n        const config = {\n            codec: this.trackInfo.codec,\n            sampleRate: this.trackInfo.sampleRate,\n            numberOfChannels: this.trackInfo.channelCount,\n        };\n        const isConfigSupported = await AudioEncoder.isConfigSupported(config);\n        if (isConfigSupported.supported === false) {\n            throw new Error('Incorrect audio decoder configuration');\n        }\n        this.decoder.configure(config);\n        this.setStatus('initialized');\n    }\n    /**\n     * Получает информацию о аудио-треке.\n     *\n     * @returns {AudioTrackInfo | null} Информация о аудио-треке и null, если информация отсутствует\n     * @public\n     */\n    getTrackInfo() {\n        return this.trackInfo;\n    }\n    getDecoder() {\n        return this.decoder;\n    }\n    /**\n     * Получает готовые аудио-samples для декодирования.\n     *\n     * @returns {Promise<GettingSamplesStatus>} Promise, разрешающийся после получения samples.\n     * @public\n     */\n    async getReadySamples() {\n        if (this.status !== 'initialized')\n            return Promise.resolve(null);\n        return new Promise(resolve => {\n            this.demuxer.demultiplex(this.trackInfo.id, samples => {\n                this.samplesCount += samples.length;\n                samples.forEach(sample => {\n                    const chunk = this.makeChunk(sample);\n                    this.chunks.push(chunk);\n                });\n                if (this.samplesCount === this.trackInfo.totalSamples) {\n                    this.emitter.emit('demuxing-complete');\n                    resolve(this.chunks);\n                }\n            });\n        });\n    }\n    /**\n     * Создает аудио-chunk для декодированного аудио-sample.\n     *\n     * @param {AudioSample} sample - Аудио-sample для создания аудио-chunk.\n     * @returns {EncodedAudioChunk} - Созданный аудио-chunk.\n     * @private\n     */\n    makeChunk(sample) {\n        const type = sample.is_sync ? 'key' : 'delta';\n        return new EncodedAudioChunk({\n            type,\n            timestamp: sample.cts,\n            duration: sample.duration,\n            data: sample.data,\n        });\n    }\n    /**\n     * Сохраняет декодированный аудио-фрейм и отправляет его по мере накопления.\n     *\n     * @param {AudioData} frame - Декодированный аудио-фрейм.\n     * @private\n     */\n    saveFrame(frame) {\n        this.sendFrames(frame);\n    }\n    /**\n     * @protected\n     */\n    async onDemuxComplete() {\n        await this.decoder.flush();\n        this.demuxer.deleteUsedVideoSamples(this.trackInfo.id, this.trackInfo.totalSamples);\n    }\n    /**\n     * @protected\n     */\n    async onDecodeComplete() {\n        super.onDecodeComplete();\n        await this.decoder.flush();\n        this.decoder.close();\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/decoder/AudioTrackDecoder.ts?");

/***/ }),

/***/ "./src/core/decoder/Decoder.ts":
/*!*************************************!*\
  !*** ./src/core/decoder/Decoder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _core_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/demuxer */ \"./src/core/demuxer/index.ts\");\n/* harmony import */ var _VideoTrackDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VideoTrackDecoder */ \"./src/core/decoder/VideoTrackDecoder.ts\");\n/* harmony import */ var _AudioTrackDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioTrackDecoder */ \"./src/core/decoder/AudioTrackDecoder.ts\");\n\n\n\n/**\n * Класс, представляющий декодер медиа-данных.\n */\nclass Decoder {\n    demuxer;\n    videoDecoder;\n    audioDecoder;\n    buffer;\n    /**\n     * Создает новый экземпляр класса Decoder.\n     *\n     * @param {ArrayBuffer} target - Целевые медиа-данные для декодирования.\n     * @param {DecoderOptions} options - Опции для декодера.\n     */\n    constructor(target, options = {}) {\n        const { outputVideoFramesSize, outputAudioFramesSize } = options;\n        this.demuxer = new _core_demuxer__WEBPACK_IMPORTED_MODULE_0__.Demuxer(target);\n        this.buffer = target;\n        this.videoDecoder = new _VideoTrackDecoder__WEBPACK_IMPORTED_MODULE_1__.VideoTrackDecoder(this.demuxer, { outputFramesSize: outputVideoFramesSize });\n        this.audioDecoder = new _AudioTrackDecoder__WEBPACK_IMPORTED_MODULE_2__.AudioTrackDecoder(this.demuxer, { outputFramesSize: outputAudioFramesSize });\n    }\n    /**\n     * Выполняет настройку медиа-данных для декодирования\n     *\n     * @returns {Promise<MediaInfo>} Объект, представляющий информацию о медиа.\n     * @public\n     */\n    async setupMedia() {\n        const videoTrackInfo = this.videoDecoder.getTrackInfo();\n        const audioTrackInfo = this.audioDecoder.getTrackInfo();\n        try {\n            await Promise.all([this.videoDecoder.initializeDecoder(), this.audioDecoder.initializeDecoder()]);\n        }\n        catch (error) {\n            throw error;\n        }\n        return {\n            video: videoTrackInfo,\n            audio: audioTrackInfo,\n        };\n    }\n    /**\n     * Регистрирует обработчик для декодированных видео-кадров.\n     *\n     * @param {DecodedVideoFramesResultFn} callback - Функция обратного вызова для видео-кадров.\n     * @public\n     */\n    onVideoFrames(callback) {\n        this.videoDecoder.onFrames(callback);\n    }\n    /**\n     * Регистрирует обработчик для декодированных аудио-фреймов.\n     *\n     * @param {DecodedAudioFramesResultFn} callback - Функция обратного вызова для аудио-фреймов.\n     * @public\n     */\n    onAudioFrames(callback) {\n        this.audioDecoder.onFrames(callback);\n    }\n    /**\n     * Получить видео-decoder\n     * @public\n     */\n    getVideoDecoder() {\n        return this.videoDecoder.getDecoder();\n    }\n    /**\n     * Получить аудио-decoder\n     * @public\n     */\n    getAudioDecoder() {\n        return this.audioDecoder.getDecoder();\n    }\n    /**\n     * Начинает процесс декодирования видео-данных и возвращает результат\n     * @public\n     */\n    async getReadyVideoChunks() {\n        return await this.videoDecoder.getReadySamples();\n    }\n    /**\n     * Начинает процесс декодирования аудио-данных и возвращает результат\n     * @public\n     */\n    async getReadyAudioChunks() {\n        return await this.audioDecoder.getReadySamples();\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/decoder/Decoder.ts?");

/***/ }),

/***/ "./src/core/decoder/VideoTrackDecoder.ts":
/*!***********************************************!*\
  !*** ./src/core/decoder/VideoTrackDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoTrackDecoder: () => (/* binding */ VideoTrackDecoder)\n/* harmony export */ });\n/* harmony import */ var _AbstractMediaTrackDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractMediaTrackDecoder */ \"./src/core/decoder/AbstractMediaTrackDecoder.ts\");\n\nconst sleep = async (ms) => await new Promise(res => setTimeout(res, ms));\n// const Convert = () =>\n// const frameIndex = Math.round(timestamp / 35) % frames.length;\n/**\n * Класс `VideoTrackDecoder` представляет собой декодер видео-треков.\n * Он наследует абстрактный класс `AbstractMediaTrackDecoder`.\n */\nclass VideoTrackDecoder extends _AbstractMediaTrackDecoder__WEBPACK_IMPORTED_MODULE_0__.AbstractMediaTrackDecoder {\n    decoder;\n    trackInfo;\n    chunks = [];\n    /**\n     * Создает экземпляр класса `VideoTrackDecoder`.\n     *\n     * @param {Demuxer} demuxer - Объект demuxer, предоставляющий доступ к данным видео-трека.\n     * @param {VideoDecoderOptions} options - Дополнительные опции для настройки декодера видео.\n     */\n    constructor(demuxer, options = {}) {\n        super(demuxer, options);\n        this.trackInfo = this.demuxer.getVideoTrackInfo();\n    }\n    /**\n     * Инициализирует декодер видео.\n     *\n     * @returns {Promise<void>} Promise, разрешающийся после инициализации декодера.\n     * @public\n     */\n    async initializeDecoder() {\n        this.decoder = new VideoDecoder({\n            output: videoFrame => {\n                this.saveFrame(videoFrame);\n            },\n            error: e => {\n                console.log('Video Decode Error: ', e);\n                console.dir(e);\n            },\n        });\n        /*\n            TODO: Заменить на\n\n            const { supported } = await VideoDecoder.isConfigSupported(config);\n            if (supported) {\n                const decoder = new VideoDecoder(init);\n                decoder.configure(config);\n            } else {\n                Try another config.\n            }\n        */\n        const config = {\n            codec: this.trackInfo.codec,\n            description: this.trackInfo.extradata,\n            hardwareAcceleration: 'prefer-hardware',\n            optimizeForLatency: true,\n        };\n        const isConfigSupported = await VideoDecoder.isConfigSupported(config);\n        if (isConfigSupported.supported === false) {\n            throw new Error('Incorrect video decoder configuration');\n        }\n        this.decoder.configure(config);\n    }\n    /**\n     * @returns {VideoTrackInfo} Информация о видео-треке.\n     * @public\n     */\n    getTrackInfo() {\n        return this.demuxer.getVideoTrackInfo();\n    }\n    getDecoder() {\n        return this.decoder;\n    }\n    async getReadySamples() {\n        return new Promise(resolve => {\n            this.demuxer.demultiplex(this.trackInfo.id, samples => {\n                this.samplesCount += samples.length;\n                samples.forEach(sample => {\n                    const chunk = this.makeChunk(sample);\n                    this.chunks.push(chunk);\n                });\n                resolve(this.chunks);\n            });\n        });\n    }\n    /**\n     * Сохраняет декодированный фрейм, создает и отправляет фреймы по мере накопления.\n     *\n     * @param {VideoFrame} frame - Декодированный видео-фрейм.\n     * @private\n     */\n    async saveFrame(frame) {\n        this.sendFrames(frame);\n    }\n    /**\n     * Создает видео-chunk для декодированного видео-sample-a.\n     *\n     * @param {VideoSample} sample - Видео-sample для создания видео-chunk-a.\n     * @returns {EncodedVideoChunk} - Созданный видео-chunk.\n     * @private\n     */\n    makeChunk(sample) {\n        const type = sample.is_sync ? 'key' : 'delta';\n        return new EncodedVideoChunk({\n            type: type,\n            timestamp: sample.dts,\n            duration: sample.duration,\n            data: sample.data,\n        });\n    }\n    /**\n     * @protected\n     */\n    async onDemuxComplete() {\n        console.log('VIDEO onDemuxComplete');\n        try {\n            await this.decoder.flush();\n            // this.demuxer.deleteUsedVideoSamples(this.trackInfo.id, this.trackInfo.totalSamples);\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }\n    /**\n     * @protected\n     */\n    async onDecodeComplete() {\n        console.log('VIDEO onDecodeComplete');\n        // super.onDecodeComplete();\n        // try {\n        //     await this.decoder.flush();\n        //     this.decoder.close();\n        // } catch(e) {\n        //     console.log(e)\n        // }\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/decoder/VideoTrackDecoder.ts?");

/***/ }),

/***/ "./src/core/decoder/index.ts":
/*!***********************************!*\
  !*** ./src/core/decoder/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* reexport safe */ _Decoder__WEBPACK_IMPORTED_MODULE_0__.Decoder)\n/* harmony export */ });\n/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder */ \"./src/core/decoder/Decoder.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/decoder/index.ts?");

/***/ }),

/***/ "./src/core/demuxer/Demuxer.ts":
/*!*************************************!*\
  !*** ./src/core/demuxer/Demuxer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Demuxer: () => (/* binding */ Demuxer)\n/* harmony export */ });\n/* harmony import */ var mp4box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mp4box */ \"./node_modules/mp4box/dist/mp4box.all.js\");\n/* harmony import */ var _MP4BoxFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MP4BoxFile */ \"./src/core/demuxer/MP4BoxFile.ts\");\n\n\n/*\n    * Demuxer (от английского \"demultiplexer\") - это компонент или программа, которая выполняет процесс демультиплексирования.\n    * Демультиплексирование - это процесс разбора и извлечения различных компонентов (или потоков) из многоканального или многокомпонентного источника данных.\n\n    Demuxer выполняет следующие основные функции:\n        * Разбор данных: Demuxer разбирает входные данные и определяет, какие компоненты данных\n            (например, аудио, видео, текстовые данные) содержатся в исходном потоке.\n\n        * Извлечение потоков: После разбора данных Demuxer извлекает отдельные потоки данных для каждой компоненты.\n            Например, в случае видеофайла Demuxer извлечет видеопоток и аудио-поток.\n\n        * Передача потоков декодерам: Эти извлеченные потоки данных затем передаются соответствующим декодерам (например, видео-декодерам и аудио-декодерам),\n            которые декодируют данные и делают их доступными для воспроизведения или дальнейшей обработки.\n*/\nclass Demuxer {\n    source;\n    videoTrack = null;\n    audioTrack = null;\n    /**\n     * Создает экземпляр класса Demuxer и инициализирует его.\n     *\n     * @param {ArrayBuffer} buffer - ArrayBuffer, содержащий данные MP4-файла.\n     */\n    constructor(buffer) {\n        this.source = new _MP4BoxFile__WEBPACK_IMPORTED_MODULE_1__.MP4BoxFile(buffer);\n        this.parseMediaMetadata();\n    }\n    /**\n     * Получает информацию о видео-треке, если он есть.\n     *\n     * @returns {VideoTrackInfo | null} Информация о видео-треке, такая как длительность, частота кадров, кодек и прочее.\n     */\n    getVideoTrackInfo() {\n        if (this.videoTrack == null)\n            return null;\n        const { id, duration, timescale, codec, bitrate, nb_samples, track_width, track_height } = this.videoTrack;\n        const durationInMilliseconds = (duration / timescale) * 1000;\n        const framerate = Math.round(1000 / (durationInMilliseconds / nb_samples));\n        return {\n            id,\n            duration,\n            durationInMilliseconds,\n            framerate,\n            bitrate,\n            timescale,\n            codec,\n            extradata: this.getVideoDescription(this.videoTrack),\n            totalSamples: nb_samples,\n            originalWidth: track_width,\n            originalHeight: track_height,\n        };\n    }\n    /**\n     * Получает информацию о аудио-треке, если он есть.\n     *\n     * @returns {AudioTrackInfo | null} Информация о аудио-треке, такая как длительность, битрейт, кодек и прочее.\n     */\n    getAudioTrackInfo() {\n        if (this.audioTrack == null)\n            return null;\n        const { id, duration, audio, timescale, codec, bitrate, nb_samples } = this.audioTrack;\n        const durationInMilliseconds = (duration / timescale) * 1000;\n        return {\n            id,\n            duration,\n            durationInMilliseconds,\n            timescale,\n            codec,\n            bitrate,\n            channelCount: audio.channel_count,\n            sampleRate: audio.sample_rate,\n            totalSamples: nb_samples,\n        };\n    }\n    /**\n     * Освобождает память, выделенную для использованных samples (как для видео, так и для аудио).\n     *\n     * @param {number} trackId - Идентификатор трека, для которого освобождается память.\n     * @param {number} countSamples - Количество использованных samples, для которых освобождается память.\n     */\n    deleteUsedVideoSamples(trackId, countSamples) {\n        this.source.releaseMemoryUpToSample(trackId, countSamples);\n    }\n    /**\n     * Начинает демультиплексирование видео-трека и передает данные через функцию обратного вызова.\n     *\n     * @param {number} trackId - ID трека, для которого начинается обработка.\n     * @param {DemultiplexCallback} cb - Функция обратного вызова для получения данных (samples) для видео или аудио.\n     */\n    demultiplex(trackId, cb) {\n        this.source.start(trackId, cb);\n    }\n    /**\n     * Извлекает информацию о видео и аудио из метаданных медиа.\n     *\n     * @private\n     */\n    parseMediaMetadata() {\n        let info = this.source.getFileInfo();\n        if (info.videoTracks.length > 0)\n            this.videoTrack = info.videoTracks[0];\n        else\n            this.videoTrack = null;\n        if (info.audioTracks.length > 0)\n            this.audioTrack = info.audioTracks[0];\n        else\n            this.audioTrack = null;\n    }\n    /**\n     * Внутренний метод для получения заголовка видео из трека.\n     *\n     * @param {MP4VideoTrack} videoTrack - Видео-трек для извлечения заголовка.\n     * @returns {Uint8Array} Заголовок видео.\n     * @throws {Error} Если не найден avcC, hvcC, vpcC или av1C box.\n     * @private\n     */\n    getVideoDescription(videoTrack) {\n        const trak = this.source.getTrackById(videoTrack.id);\n        for (const entry of trak.mdia.minf.stbl.stsd.entries) {\n            const box = entry.avcC || entry.hvcC || entry.vpcC || entry.av1C;\n            if (box) {\n                const stream = new mp4box__WEBPACK_IMPORTED_MODULE_0__.DataStream(undefined, 0, mp4box__WEBPACK_IMPORTED_MODULE_0__.DataStream.BIG_ENDIAN);\n                box.write(stream);\n                return new Uint8Array(stream.buffer, 8);\n            }\n        }\n        throw new Error('avcC, hvcC, vpcC, or av1C box not found');\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/demuxer/Demuxer.ts?");

/***/ }),

/***/ "./src/core/demuxer/MP4BoxFile.ts":
/*!****************************************!*\
  !*** ./src/core/demuxer/MP4BoxFile.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MP4BoxFile: () => (/* binding */ MP4BoxFile)\n/* harmony export */ });\n/* harmony import */ var mp4box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mp4box */ \"./node_modules/mp4box/dist/mp4box.all.js\");\n\n/*\n    TODO: добавить возможность добавления buffer с помощью стрима\n*/\n/**\n * Представляет класс для работы с MP4-файлами с использованием библиотеки MP4Box.\n */\nclass MP4BoxFile {\n    file;\n    info;\n    _onChunk;\n    /**\n     * Создает экземпляр класса MP4BoxFile.\n     *\n     * @param {ArrayBuffer} buffer - ArrayBuffer, содержащий данные MP4-файла.\n     */\n    constructor(buffer) {\n        this.file = mp4box__WEBPACK_IMPORTED_MODULE_0__.createFile();\n        this.file.onError = console.error.bind(console);\n        this.file.onReady = this.onReady.bind(this);\n        this.file.onSamples = this.onSamples.bind(this);\n        this.initializeBuffer(buffer);\n    }\n    /**\n     * Инициализирует буфер данных.\n     *\n     * @param {ArrayBuffer} buffer - ArrayBuffer, содержащий данные MP4-файла.\n     * @private\n     */\n    initializeBuffer(buffer) {\n        const mp4Buffer = buffer;\n        mp4Buffer.fileStart = 0;\n        this.file.appendBuffer(mp4Buffer);\n        this.file.flush();\n    }\n    /**\n     * Обработчик события \"onReady\".\n     *\n     * @param {MP4Info} info - Информация о MP4-файле.\n     * @private\n     */\n    onReady(info) {\n        this.info = info;\n    }\n    /**\n     * Обработчик события \"onSamples\".\n     *\n     * @param {number} _track_id - Идентификатор трека.\n     * @param {unknown} _ref - Пользовательский объект (не используется).\n     * @param {MP4Sample[]} samples - Samples.\n     * @private\n     */\n    onSamples(_track_id, _ref, samples) {\n        this._onChunk(samples);\n    }\n    /**\n     * Выбирает трек для обработки по его ID.\n     *\n     * @param {number} trackId - ID трека.\n     * @private\n     */\n    selectTrack(trackId) {\n        this.file.setExtractionOptions(trackId, null, { nbSamples: 500 });\n    }\n    /**\n     * Получает информацию о MP4-файле.\n     *\n     * @returns {MP4Info} Информация о MP4-файле.\n     */\n    getFileInfo() {\n        return this.info;\n    }\n    /**\n     * Получает трек по его идентификатору.\n     *\n     * @param {number} trackId - Идентификатор трека для получения.\n     * @returns {Trak | null} Трек с указанным идентификатором или null, если не найден.\n     */\n    getTrackById(trackId) {\n        return this.file.getTrackById(trackId);\n    }\n    /**\n     * Освобождает память, выделенную для данных samples для указанного трека до указанного номера sample (исключая этот номер).\n     *\n     * @param {number} trackId - Идентификатор трека, для которого будут получены samples.\n     * @param {number} sampleNumber - Номер sample, до которого следует освободить память (исключая этот номер).\n     */\n    releaseMemoryUpToSample(trackId, sampleNumber) {\n        this.file.releaseUsedSamples(trackId, sampleNumber);\n    }\n    /**\n     * Начинает обработку MP4-файла для указанного трека (по его ID).\n     *\n     * @param {number} trackId - ID трека, для которого начинается обработка.\n     * @param {DemultiplexCallback} callback - Функция обратного вызова для получения данных samples.\n     */\n    start(trackId, callback) {\n        this._onChunk = callback;\n        this.selectTrack(trackId);\n        this.file.start();\n    }\n    /**\n     * Останавливает обработку MP4-файла.\n     */\n    stop() {\n        this.file.stop();\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/demuxer/MP4BoxFile.ts?");

/***/ }),

/***/ "./src/core/demuxer/index.ts":
/*!***********************************!*\
  !*** ./src/core/demuxer/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Demuxer: () => (/* reexport safe */ _Demuxer__WEBPACK_IMPORTED_MODULE_0__.Demuxer)\n/* harmony export */ });\n/* harmony import */ var _Demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Demuxer */ \"./src/core/demuxer/Demuxer.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/demuxer/index.ts?");

/***/ }),

/***/ "./src/core/emitter/Emitter.ts":
/*!*************************************!*\
  !*** ./src/core/emitter/Emitter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\nclass EventEmitter {\n    listeners = new Map();\n    on(event, listener) {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        const found = this.listeners.get(event);\n        if (found) {\n            found.add(listener);\n        }\n        return () => {\n            const exists = this.listeners.get(event);\n            if (exists) {\n                exists.delete(listener);\n            }\n        };\n    }\n    once(event, listener) {\n        const unsubscribe = this.on(event, value => {\n            listener(value);\n            unsubscribe();\n        });\n        return unsubscribe;\n    }\n    emit(event, value) {\n        const listeners = this.listeners.get(event);\n        if (listeners) {\n            listeners.forEach(fn => fn(value));\n        }\n    }\n    emitCallback(event) {\n        return value => this.emit(event, value);\n    }\n    off(event) {\n        this.listeners.delete(event);\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/emitter/Emitter.ts?");

/***/ }),

/***/ "./src/core/emitter/index.ts":
/*!***********************************!*\
  !*** ./src/core/emitter/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport safe */ _Emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter)\n/* harmony export */ });\n/* harmony import */ var _Emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Emitter */ \"./src/core/emitter/Emitter.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/emitter/index.ts?");

/***/ }),

/***/ "./src/core/encoder/Encoder.ts":
/*!*************************************!*\
  !*** ./src/core/encoder/Encoder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _core_muxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/muxer */ \"./src/core/muxer/index.ts\");\n\nclass Encoder {\n    muxer;\n    videoEncoder;\n    async initialize(options) {\n        this.muxer = new _core_muxer__WEBPACK_IMPORTED_MODULE_0__.Muxer(options);\n        this.videoEncoder = new VideoEncoder({\n            output: (chunk, meta) => {\n                this.muxer.addVideoChunk(chunk, meta);\n            },\n            error: e => console.error(e),\n        });\n        /*\n            avc1.42001f: (1984*1088=2158592) | max = 921600 пикселей, поддержка уровня AVC (3.1), который указан в кодеке.\n            avc1.640028: (1984*1088=2158592) | max = 2097152 пикселей, поддержка уровня AVC (4.0), который указан в кодеке.\n        */\n        this.videoEncoder.configure({\n            codec: 'avc1.640032',\n            width: options.width,\n            height: options.height,\n            bitrate: options.bitrate,\n        });\n    }\n    encodeVideoFrame(frame, options) {\n        this.videoEncoder.encode(frame, options);\n    }\n    async finish() {\n        console.log('finish');\n        await this.videoEncoder.flush();\n        const buffer = this.muxer.finish();\n        return buffer;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/encoder/Encoder.ts?");

/***/ }),

/***/ "./src/core/encoder/index.ts":
/*!***********************************!*\
  !*** ./src/core/encoder/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encoder: () => (/* reexport safe */ _Encoder__WEBPACK_IMPORTED_MODULE_0__.Encoder)\n/* harmony export */ });\n/* harmony import */ var _Encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder */ \"./src/core/encoder/Encoder.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/encoder/index.ts?");

/***/ }),

/***/ "./src/core/engine/Engine.ts":
/*!***********************************!*\
  !*** ./src/core/engine/Engine.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: () => (/* binding */ Engine)\n/* harmony export */ });\nclass VideoFrameQueue {\n    decodedFrames = [];\n    lastDecodedFrame = null;\n    append(frame) {\n        this.decodedFrames.push(frame);\n        if (this.lastDecodedFrame) {\n            this.lastDecodedFrame.close();\n        }\n    }\n    take() {\n        const frame = this.decodedFrames.shift();\n        this.lastDecodedFrame = frame;\n        return frame;\n    }\n    takeLastDecodedFrame() {\n        return this.lastDecodedFrame;\n    }\n    clear() {\n        this.decodedFrames = [];\n        if (this.lastDecodedFrame) {\n            this.lastDecodedFrame.close();\n            this.lastDecodedFrame = null;\n        }\n    }\n}\nclass Trace {\n    lastKeyFrameIdx = 0;\n    lastFrameIdx = 0;\n    endFrameIdx;\n    status = 'fulled';\n    constructor(totalChunks) {\n        this.endFrameIdx = totalChunks - 1;\n    }\n    setTraceTrack(keyIdx, idx) {\n        this.status = 'sliced';\n        this.lastKeyFrameIdx = keyIdx;\n        this.lastFrameIdx = idx;\n    }\n    setLastTrackPont(idx) {\n        this.lastFrameIdx = idx;\n    }\n    getStatus() {\n        return this.status;\n    }\n    lastProcessingTrack() {\n        return {\n            start: this.lastKeyFrameIdx,\n            past: this.lastFrameIdx,\n            end: this.endFrameIdx,\n        };\n    }\n    watchingMovementTrace(type, idx) {\n        if (type === 'key') {\n            this.lastKeyFrameIdx = idx;\n        }\n        this.lastFrameIdx = idx;\n    }\n    resetTrace() {\n        this.status = 'fulled';\n        this.lastKeyFrameIdx = 0;\n        this.lastFrameIdx = 0;\n    }\n}\nclass TraceSegments {\n    traces = new Map();\n    create(videoInfo) {\n        const { id, totalChunks } = videoInfo;\n        const trace = new Trace(totalChunks);\n        this.traces.set(id, trace);\n    }\n    getTrace(videoId) {\n        return this.traces.get(videoId);\n    }\n    setNewTrackTrace(videoId, track) {\n        const trace = this.getTrace(videoId);\n        trace.setTraceTrack(track.keyIdx, track.idx);\n        this.resetTraceExcept(videoId);\n    }\n    resetTraceExcept(videoId) {\n        Array.from(this.traces.keys()).forEach(id => {\n            if (id !== videoId) {\n                this.getTrace(id).resetTrace();\n            }\n        });\n    }\n    resetTraces() {\n        Array.from(this.traces.values()).forEach(trace => trace.resetTrace());\n    }\n}\nclass Engine {\n    /*\n     ****\n     */\n    canvas;\n    segments;\n    traces;\n    /*\n     *****\n     */\n    lastStatus = null;\n    status = 'pending';\n    queue;\n    currentPlayingVideoId = null;\n    constructor({ canvas, segments }) {\n        this.canvas = canvas;\n        this.segments = segments;\n        this.queue = new VideoFrameQueue();\n        this.traces = new TraceSegments();\n        /*\n            Подписка на добавление сегментов\n        */\n        this.segments.onVideoAdded(data => this.traces.create(data));\n        this.segments.onImageAdded(() => this.renderFromLastSavedFrame());\n        /*\n            Подписка на изменение сегментов\n        */\n        this.segments.onImagePositionChange(() => this.renderFromLastSavedFrame());\n        this.segments.onFilterChange(() => this.renderFromLastSavedFrame());\n        /*\n            Подписка на изменение последовательности видео\n        */\n        this.segments.onOrderChanged(() => this.renderRollBack());\n    }\n    /*\n     ****\n     */\n    getCurrentVideoSegmentById(videoId) {\n        return this.segments.getVideoSegmentById(videoId);\n    }\n    setCurrentPlayingVideoId(videoId) {\n        this.currentPlayingVideoId = videoId;\n    }\n    /*\n     ***** Render\n     */\n    async renderFirstFrameOfLeadingVideo(videoId) {\n        this.setCurrentPlayingVideoId(videoId);\n        const segments = this.getCurrentVideoSegmentById(videoId);\n        const engine = segments.getEngine();\n        engine.frameChannel((frame) => {\n            this.queue.append(frame);\n            this.drawScene();\n        });\n        engine.decoder.decode(engine.chunksWorker.firstChunk);\n        await engine.decoder.flush();\n    }\n    /*\n     ***** Render\n     */\n    async renderPreviewFrameFromSelectedVideo(videoId, timestamp) {\n        const segment = this.getCurrentVideoSegmentById(videoId);\n        const engine = segment.getEngine();\n        const currentFrameIdx = engine.chunksWorker.findClosestFrameIdxByTimestamp(timestamp);\n        const keyIdx = engine.chunksWorker.findKeyChunkByIndex(currentFrameIdx);\n        const timestampPreviewFrame = engine.chunksWorker.chunks[currentFrameIdx].timestamp;\n        const chunks = engine.chunksWorker.slice(keyIdx, currentFrameIdx + 1);\n        this.traces.setNewTrackTrace(videoId, { keyIdx, idx: currentFrameIdx });\n        console.log('this.traces', this.traces);\n        engine.frameChannel((frame) => {\n            if (timestampPreviewFrame === frame.timestamp) {\n                this.queue.append(frame);\n                this.drawScene();\n            }\n            else {\n                frame.close();\n            }\n        });\n        let idx = 0;\n        for (const chunk of chunks) {\n            engine.decoder.decode(chunk);\n            idx += 1;\n        }\n        await engine.decoder.flush();\n    }\n    /*\n     ***** Render\n     */\n    renderRollBack() {\n        this.setStatus('pending');\n        const order = this.segments.getDisplayOrder();\n        if (order.length > 0) {\n            this.renderFirstFrameOfLeadingVideo(order[0]);\n        }\n        else {\n            this.idle();\n        }\n        this.traces.resetTraces();\n    }\n    /*\n     ***** Render\n     */\n    renderFromLastSavedFrame() {\n        this.drawScene('last');\n    }\n    /*\n     *****\n     */\n    drawScene(whatFrame = 'current') {\n        console.log(`%c currentPlayingVideoId ${this.currentPlayingVideoId}`, 'color: green;');\n        const images = this.segments.getImageSegmentsByVideoId(this.currentPlayingVideoId);\n        const imageFilter = this.segments.getFilterByVideoId(this.currentPlayingVideoId);\n        let frame = null;\n        if (whatFrame === 'last') {\n            frame = this.queue.lastDecodedFrame;\n        }\n        else {\n            frame = this.queue.take();\n        }\n        // console.group('Draw Object');\n        // console.log('frame --------->', frame.timestamp);\n        // console.log('imageFilter --->', imageFilter);\n        // console.log('images -------->', images);\n        // console.groupEnd();\n        const drawingObject = { frame, images, appliedFilter: imageFilter };\n        this.canvas.draw(drawingObject);\n    }\n    /*\n     *****\n     */\n    setStatus(newStatus) {\n        this.lastStatus = this.status;\n        this.status = newStatus;\n    }\n    idle() {\n        this.canvas.clearScene();\n        this.queue.clear();\n    }\n    /*\n     *****\n     */\n    showPreview(videoId, timestamp) {\n        console.log('showPreview', videoId);\n        this.setStatus('show-preview');\n        this.setCurrentPlayingVideoId(videoId);\n        this.renderPreviewFrameFromSelectedVideo(videoId, timestamp);\n    }\n    /*\n     *****\n     */\n    selectVideoIdThatHasAlreadyBeenSelected() {\n        return this.currentPlayingVideoId;\n    }\n    selectVideoIdThatIsNextInOrder() {\n        const order = this.segments.getDisplayOrder();\n        const currentVideoIdIdx = order.findIndex(id => id === this.currentPlayingVideoId);\n        const nextVideoId = order[currentVideoIdIdx + 1];\n        if (nextVideoId) {\n            this.setCurrentPlayingVideoId(nextVideoId);\n            return nextVideoId;\n        }\n        return null;\n    }\n    /*\n     *****\n     */\n    start() {\n        if (this.status === 'playing')\n            return;\n        this.setStatus('playing');\n        if (this.currentPlayingVideoId == null)\n            return;\n        const currentVideoId = this.selectVideoIdThatHasAlreadyBeenSelected();\n        this.renderMainFlow(currentVideoId);\n    }\n    pause() {\n        if (this.status !== 'pausing') {\n            this.setStatus('pausing');\n        }\n    }\n    continue() {\n        console.log('CONTINUE', this.status, this.isPausing, this.isShowPreview);\n        if (this.isPausing || this.isShowPreview)\n            return;\n        const currentVideoId = this.selectVideoIdThatIsNextInOrder();\n        if (currentVideoId == null) {\n            this.setStatus('pending');\n            return;\n        }\n        this.renderMainFlow(currentVideoId);\n    }\n    async renderMainFlow(videoId) {\n        console.log('================renderMainFlow===================== videoId', videoId);\n        const segments = this.getCurrentVideoSegmentById(videoId);\n        const trace = this.traces.getTrace(videoId);\n        const traceStatus = trace.getStatus();\n        const engine = segments.getEngine();\n        if (traceStatus === 'fulled') {\n            await this.renderIfPlaybackStartsWithFulledVideo(engine, trace);\n        }\n        else {\n            await this.renderIfPlaybackStartsWithSlicedVideo(engine, trace);\n        }\n        if (this.isPausing || this.isShowPreview)\n            return;\n        this.continue();\n    }\n    get shouldPlaybackStop() {\n        return this.status === 'show-preview' || this.status === 'pending';\n    }\n    get isPausing() {\n        return this.status === 'pausing';\n    }\n    get isPending() {\n        return this.status === 'pending';\n    }\n    get isShowPreview() {\n        return this.status === 'show-preview';\n    }\n    async renderIfPlaybackStartsWithFulledVideo(engine, trace) {\n        const track = trace.lastProcessingTrack();\n        const chunks = engine.chunksWorker.slice(track.start, track.end + 1);\n        console.log(trace, trace.lastProcessingTrack());\n        console.log('---------------> full video <---------------');\n        engine.frameChannel((frame) => {\n            this.queue.append(frame);\n            this.drawScene();\n        });\n        for (let idx = 0; idx < chunks.length; idx += 1) {\n            if (this.shouldPlaybackStop)\n                return;\n            if (idx + track.start < track.past)\n                continue;\n            const chunk = chunks[idx];\n            trace.watchingMovementTrace(chunk.type, idx + track.start);\n            if (this.isPausing) {\n                console.log('pausing');\n                trace.setLastTrackPont(idx + track.start);\n                return;\n            }\n            engine.decoder.decode(chunk);\n            await new Promise(res => setTimeout(res, 1000 / 30));\n        }\n        await engine.decoder.flush();\n    }\n    async renderIfPlaybackStartsWithSlicedVideo(engine, trace) {\n        const track = trace.lastProcessingTrack();\n        const chunks = engine.chunksWorker.slice(track.start, track.end + 1);\n        console.log(track);\n        const lastTimestampFrame = engine.chunksWorker.chunks[track.past].timestamp;\n        console.log('---------------> slice <---------------', lastTimestampFrame);\n        engine.frameChannel((frame) => {\n            if (frame.timestamp > lastTimestampFrame) {\n                this.queue.append(frame);\n                this.drawScene();\n            }\n            else {\n                frame.close();\n            }\n        });\n        console.log('chunks', chunks);\n        for (let idx = 0; idx < chunks.length; idx += 1) {\n            if (this.shouldPlaybackStop) {\n                return;\n            }\n            ;\n            if (idx + track.start < track.past) {\n                if (this.lastStatus === 'show-preview') {\n                    engine.decoder.decode(chunks[idx]);\n                }\n                continue;\n            }\n            const chunk = chunks[idx];\n            trace.watchingMovementTrace(chunk.type, idx + track.start);\n            if (this.isPausing || this.isShowPreview) {\n                console.log('pausing');\n                trace.setLastTrackPont(idx + track.start);\n                return;\n            }\n            engine.decoder.decode(chunk);\n            await new Promise(res => setTimeout(res, 1000 / 30));\n        }\n        await engine.decoder.flush();\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Engine.ts?");

/***/ }),

/***/ "./src/core/engine/Preview/PreviewCanvas.ts":
/*!**************************************************!*\
  !*** ./src/core/engine/Preview/PreviewCanvas.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PreviewCanvas: () => (/* binding */ PreviewCanvas)\n/* harmony export */ });\n/* harmony import */ var _libs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs */ \"./src/core/engine/Preview/libs/index.ts\");\n\nclass PreviewCanvas {\n    canvas;\n    ctx;\n    width;\n    height;\n    /**\n     * Связывает экземпляр canvas с классом.\n     *\n     * @param {OffscreenCanvas} canvas - Экземпляр canvas, с которым связывается класс.\n     */\n    linkTo(canvas) {\n        this.canvas = canvas;\n        // @ts-ignore\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n        this.width = this.canvas.width;\n        this.height = this.canvas.height;\n    }\n    /**\n     * Рисует кадр, изображения (если есть) и применяет фильтр на canvas.\n     *\n     * @param {ObjectDraw} data - Данные для отрисовки, включая кадр, изображения и фильтр.\n     */\n    draw(data) {\n        const { frame, images, appliedFilter } = data;\n        this.clearScene();\n        this.drawFrame(frame);\n        this.drawImages(images);\n        this.applyFilter(appliedFilter);\n    }\n    /**\n     * Очищает сцену на canvas.\n     */\n    clearScene() {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n    /**\n     * Рисует кадр на canvas.\n     *\n     * @param {VideoFrame} frame - Кадр для отрисовки.\n     */\n    drawFrame(frame) {\n        const { width, height } = this.resizeImageToCanvasProportions(frame.displayWidth, frame.displayHeight);\n        const { x, y } = this.calculateCenteredImagePosition(width, height);\n        this.ctx.drawImage(frame, x, y, this.width, this.height);\n    }\n    /**\n     * Рисует изображения на canvas.\n     *\n     * @param {Array<{ position: ImagePosition; image: ImageBitmap }>} images - Массив изображений для отрисовки.\n     */\n    drawImages(images) {\n        if (images == null || images.length === 0)\n            return;\n        images.forEach(segment => {\n            const { image, position } = segment;\n            const [x, y] = (0,_libs__WEBPACK_IMPORTED_MODULE_0__.getCoordinatesByPosition)(position, image.width, image.height, this.width, this.height);\n            this.ctx.drawImage(image, x, y, image.width, image.height);\n        });\n    }\n    /**\n     * Применяет фильтр к изображению на canvas.\n     *\n     * @param {ImageFilter} appliedFilter - Фильтр для применения.\n     */\n    applyFilter(appliedFilter) {\n        if (appliedFilter == null || appliedFilter === 'none')\n            return;\n        const imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n        const filterFn = (0,_libs__WEBPACK_IMPORTED_MODULE_0__.getImageFilterFn)(appliedFilter);\n        filterFn(imageData);\n        this.ctx.putImageData(imageData, 0, 0);\n    }\n    /**\n     * Рассчитывает позицию изображения с центрированием на указанных размерах.\n     *\n     * @param {number} imageWidth - Ширина изображения.\n     * @param {number} imageHeight - Высота изображения.\n     * @returns {{ x: number, y: number }} - Объект с координатами x и y для центрирования изображения.\n     */\n    calculateCenteredImagePosition(imageWidth, imageHeight) {\n        let newWidth, newHeight;\n        if (imageWidth / this.width > imageHeight / this.height) {\n            newWidth = this.width;\n            newHeight = (imageHeight / imageWidth) * this.width;\n        }\n        else {\n            newWidth = (imageWidth / imageHeight) * this.height;\n            newHeight = this.height;\n        }\n        const x = (this.width - newWidth) / 2;\n        const y = (this.height - newHeight) / 2;\n        return { x, y };\n    }\n    /**\n     * Изменяет размеры изображения с сохранением пропорций в пределах максимальной ширины и высоты.\n     *\n     * @param {number} imageWidth - Исходная ширина изображения.\n     * @param {number} imageHeight - Исходная высота изображения.\n     * @returns {{ width: number, height: number }} - Объект с новой шириной и высотой изображения.\n     */\n    resizeImageToCanvasProportions(imageWidth, imageHeight) {\n        let width = imageWidth;\n        let height = imageHeight;\n        if (width > this.width || height > this.height) {\n            const aspectRatio = width / height;\n            if (width > this.width) {\n                width = this.width;\n                height = width / aspectRatio;\n            }\n            if (height > this.height) {\n                height = this.height;\n                width = height * aspectRatio;\n            }\n        }\n        return { width, height };\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Preview/PreviewCanvas.ts?");

/***/ }),

/***/ "./src/core/engine/Preview/index.ts":
/*!******************************************!*\
  !*** ./src/core/engine/Preview/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PreviewCanvas: () => (/* reexport safe */ _PreviewCanvas__WEBPACK_IMPORTED_MODULE_0__.PreviewCanvas)\n/* harmony export */ });\n/* harmony import */ var _PreviewCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PreviewCanvas */ \"./src/core/engine/Preview/PreviewCanvas.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Preview/index.ts?");

/***/ }),

/***/ "./src/core/engine/Preview/libs/imageFilters.ts":
/*!******************************************************!*\
  !*** ./src/core/engine/Preview/libs/imageFilters.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImageFilterFn: () => (/* binding */ getImageFilterFn)\n/* harmony export */ });\n/*\n    filter: grayscale(100%);\n*/\nfunction grayscale(imageData) {\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n        data[i] = brightness;\n        data[i + 1] = brightness;\n        data[i + 2] = brightness;\n    }\n    return imageData;\n}\n/*\n     filter: ;\n*/\nfunction sepia(imageData) {\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        data[i] = r * 0.393 + g * 0.769 + b * 0.189;\n        data[i + 1] = r * 0.349 + g * 0.686 + b * 0.168;\n        data[i + 2] = r * 0.272 + g * 0.534 + b * 0.131;\n    }\n    return imageData;\n}\n/*\n    filter: ;\n*/\nfunction invert(imageData) {\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n        data[i] = 255 - data[i];\n        data[i + 1] = 255 - data[i + 1];\n        data[i + 2] = 255 - data[i + 2];\n    }\n    return imageData;\n}\n/*\n    filter: ; (Фильтр Яркости)\n*/\nfunction brightness(imageData, factor = 1.5) {\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n        data[i] = Math.min(255, data[i] * factor);\n        data[i + 1] = Math.min(255, data[i + 1] * factor);\n        data[i + 2] = Math.min(255, data[i + 2] * factor);\n    }\n    return imageData;\n}\n/*\n     filter: brightness(50%);\n*/\nfunction darken(imageData, factor = 0.5) {\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n        data[i] = data[i] * factor;\n        data[i + 1] = data[i + 1] * factor;\n        data[i + 2] = data[i + 2] * factor;\n    }\n    return imageData;\n}\nfunction none(imageData) {\n    return imageData;\n}\nconst filterDictionary = {\n    grayscale,\n    sepia,\n    invert,\n    brightness,\n    darken,\n    none,\n};\nfunction getImageFilterFn(filterType) {\n    return filterDictionary[filterType];\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Preview/libs/imageFilters.ts?");

/***/ }),

/***/ "./src/core/engine/Preview/libs/imagePositions.ts":
/*!********************************************************!*\
  !*** ./src/core/engine/Preview/libs/imagePositions.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoordinatesByPosition: () => (/* binding */ getCoordinatesByPosition)\n/* harmony export */ });\nfunction getCoordinatesByPosition(position, width, height, canvasWidth, canvasHeight) {\n    switch (position) {\n        case 'top':\n            return [canvasWidth - width, 0];\n        case 'right': {\n            return [canvasWidth - width, canvasHeight - height];\n        }\n        case 'bottom': {\n            return [0, canvasHeight - height];\n        }\n        case 'left': {\n            return [0, 0];\n        }\n        case 'center': {\n            return [(canvasWidth - width) / 2, (canvasHeight - height) / 2];\n        }\n        default:\n            break;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Preview/libs/imagePositions.ts?");

/***/ }),

/***/ "./src/core/engine/Preview/libs/index.ts":
/*!***********************************************!*\
  !*** ./src/core/engine/Preview/libs/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCoordinatesByPosition: () => (/* reexport safe */ _imagePositions__WEBPACK_IMPORTED_MODULE_1__.getCoordinatesByPosition),\n/* harmony export */   getImageFilterFn: () => (/* reexport safe */ _imageFilters__WEBPACK_IMPORTED_MODULE_0__.getImageFilterFn)\n/* harmony export */ });\n/* harmony import */ var _imageFilters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageFilters */ \"./src/core/engine/Preview/libs/imageFilters.ts\");\n/* harmony import */ var _imagePositions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagePositions */ \"./src/core/engine/Preview/libs/imagePositions.ts\");\n\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Preview/libs/index.ts?");

/***/ }),

/***/ "./src/core/engine/Segments/Segments.ts":
/*!**********************************************!*\
  !*** ./src/core/engine/Segments/Segments.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageSegment: () => (/* binding */ ImageSegment),\n/* harmony export */   Segments: () => (/* binding */ Segments),\n/* harmony export */   VideoSegment: () => (/* binding */ VideoSegment),\n/* harmony export */   VideoSegments: () => (/* binding */ VideoSegments)\n/* harmony export */ });\n/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/emitter */ \"./src/core/emitter/index.ts\");\n/* harmony import */ var _libs_generateId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/libs/generateId */ \"./src/libs/generateId.ts\");\n\n\nclass ChunksWorker {\n    videoChunks;\n    constructor(videoChunks) {\n        this.videoChunks = videoChunks;\n    }\n    get chunks() {\n        return this.videoChunks;\n    }\n    get firstChunk() {\n        return this.videoChunks[0];\n    }\n    get lastChunk() {\n        return this.videoChunks.at(-1);\n    }\n    slice(start, end = 0) {\n        return this.chunks.slice(start, end);\n    }\n    findKeyChunkByIndex(idx) {\n        const chunk = this.chunks[idx];\n        if (chunk && chunk.type === 'key')\n            return idx;\n        let counter = idx - 1;\n        while (true) {\n            if (counter === 0)\n                return 0;\n            const chunk = this.chunks[counter];\n            if (chunk && chunk.type === 'key') {\n                return counter;\n            }\n            counter -= 1;\n        }\n    }\n    findClosestFrameIdxByTimestamp(timestamp) {\n        let closestFrame = null;\n        let closestDiff = Infinity;\n        let closestIdx = 0;\n        let idx = 0;\n        for (const chunk of this.chunks) {\n            const timeDiff = Math.abs(timestamp - chunk.timestamp);\n            if (timeDiff < closestDiff) {\n                closestDiff = timeDiff;\n                closestFrame = chunk;\n                closestIdx = idx;\n            }\n            idx += 1;\n        }\n        return closestIdx;\n    }\n}\nclass VideoSegment {\n    media;\n    originalInfo;\n    chunksWorker;\n    decoder;\n    frameChannel;\n    id;\n    positionAtCreated;\n    startTime = 0;\n    endTime;\n    endTimePosition;\n    isVisibility = true;\n    constructor({ id, media, positionAtCreated }) {\n        this.id = id;\n        this.media = media;\n        this.positionAtCreated = positionAtCreated;\n        this.decoder = this.media.videoDecoder;\n        this.frameChannel = this.media.onVideoFrames.bind(this.media);\n        this.originalInfo = this.media.videoInfo;\n        this.endTime = (this.originalInfo.duration / this.originalInfo.timescale) * 1_000;\n        this.endTimePosition = this.endTime;\n    }\n    /**/\n    async startProcessGettingChunks() {\n        const chunks = await this.media.retrieveVideoChunks();\n        this.chunksWorker = new ChunksWorker(chunks);\n        return this;\n    }\n    /**/\n    getPositionOfCreationTime() {\n        return this.positionAtCreated;\n    }\n    /**/\n    getTimePosition() {\n        return { start: this.startTime, end: this.endTime, endPosition: this.endTimePosition };\n    }\n    updateTimePosition(start, end) {\n        this.startTime = start;\n        this.endTimePosition = end;\n    }\n    /**/\n    getSegmentInfo() {\n        return {\n            id: this.id,\n            start: this.startTime,\n            duration: this.originalInfo.duration,\n            timescale: this.originalInfo.timescale,\n            totalChunks: this.originalInfo.totalSamples,\n        };\n    }\n    /**/\n    getEngine() {\n        return {\n            decoder: this.decoder,\n            chunksWorker: this.chunksWorker,\n            frameChannel: this.frameChannel.bind(this),\n        };\n    }\n    getVisibilityState() {\n        return this.isVisibility;\n    }\n    /**/\n    changeVisibilityState() {\n        this.isVisibility = !this.isVisibility;\n    }\n}\nclass VideoSegments {\n    segments = new Map();\n    orderOfInsertionByVisibilityState = new Map();\n    numberOfTrackedVideoSegmentPosition = 0;\n    async create(media) {\n        const id = (0,_libs_generateId__WEBPACK_IMPORTED_MODULE_1__.generateId)();\n        const videoSegment = await new VideoSegment({\n            id,\n            media,\n            positionAtCreated: this.numberOfTrackedVideoSegmentPosition,\n        }).startProcessGettingChunks();\n        const positionTime = this.updateVideoSegmentPosition(this.lastSegments, videoSegment);\n        videoSegment.updateTimePosition(positionTime.start, positionTime.end);\n        this.segments.set(id, videoSegment);\n        this.orderOfInsertionByVisibilityState.set(this.numberOfTrackedVideoSegmentPosition, { id, visibility: true });\n        this.numberOfTrackedVideoSegmentPosition += 1;\n        return videoSegment.getSegmentInfo();\n    }\n    get lastSegments() {\n        const values = Array.from(this.segments.values());\n        if (values.length === 0)\n            return null;\n        return values.at(-1);\n    }\n    getSegmentById(id) {\n        return this.segments.get(id);\n    }\n    updateVisibilityStateAndGetUpdatedOrder(videoId) {\n        const currentSegment = this.getSegmentById(videoId);\n        const visibilityState = currentSegment.getVisibilityState();\n        const position = currentSegment.getPositionOfCreationTime();\n        if (visibilityState) {\n            this.disableVisibilityState(position);\n        }\n        else {\n            this.enableVisibilityStateFromOrder(position);\n        }\n        currentSegment.changeVisibilityState();\n        const updatedOrder = this.getUpdatedOrder();\n        const updatedTimePositions = this.recalculateVideoPositions(updatedOrder);\n        return { order: updatedOrder, timePositions: updatedTimePositions };\n    }\n    enableVisibilityStateFromOrder(position) {\n        const stateByPosition = this.orderOfInsertionByVisibilityState.get(position);\n        stateByPosition.visibility = true;\n        this.orderOfInsertionByVisibilityState.set(position, stateByPosition);\n    }\n    disableVisibilityState(position) {\n        const stateByPosition = this.orderOfInsertionByVisibilityState.get(position);\n        stateByPosition.visibility = false;\n        this.orderOfInsertionByVisibilityState.set(position, stateByPosition);\n    }\n    getUpdatedOrder() {\n        const values = Array.from(this.orderOfInsertionByVisibilityState.values());\n        return values.filter(value => value.visibility === true).map(value => value.id);\n    }\n    recalculateVideoPositions(order) {\n        let idx = 0;\n        const result = [];\n        for (const id of order) {\n            const lastIdx = idx - 1;\n            const currentSegment = this.getSegmentById(id);\n            const lastSegment = this.getSegmentById(order[lastIdx]);\n            const positionTime = this.updateVideoSegmentPosition(lastSegment, currentSegment);\n            currentSegment.updateTimePosition(positionTime.start, positionTime.end);\n            result.push([id, currentSegment.getTimePosition().start]);\n            idx += 1;\n        }\n        return result;\n    }\n    updateVideoSegmentPosition(lastVideoSegment, currentVideoSegment) {\n        const currentTime = currentVideoSegment.getTimePosition();\n        if (lastVideoSegment) {\n            const lastTime = lastVideoSegment.getTimePosition();\n            const startTime = lastTime.endPosition;\n            const endTime = currentTime.end + lastTime.endPosition;\n            return { start: startTime, end: endTime };\n        }\n        return { start: 0, end: currentTime.end };\n    }\n}\nclass ImageSegment {\n    id;\n    image;\n    position;\n    constructor(id, image) {\n        this.id = id;\n        this.image = image;\n        this.position = 'center';\n    }\n    changePosition(newPosition) {\n        // console.log()\n        this.position = newPosition;\n        return newPosition;\n    }\n    getInfo() {\n        return {\n            image: this.image,\n            position: this.position,\n        };\n    }\n}\nclass ImageSegments {\n    segments = new Map();\n    segmentsByVideo = new Map();\n    createImageSegment(relatedVideoId, image) {\n        const id = (0,_libs_generateId__WEBPACK_IMPORTED_MODULE_1__.generateId)();\n        const imageSegment = new ImageSegment(id, image);\n        this.segments.set(id, imageSegment);\n        this.createLinkWithVideo(relatedVideoId, id);\n        return id;\n    }\n    createLinkWithVideo(relatedVideoId, imageId) {\n        const hasVideoId = this.segmentsByVideo.has(relatedVideoId);\n        if (hasVideoId === false) {\n            this.segmentsByVideo.set(relatedVideoId, []);\n        }\n        const imageIds = this.segmentsByVideo.get(relatedVideoId);\n        imageIds.push(imageId);\n    }\n    changePosition(imageId, newPosition) {\n        const segment = this.getImageSegmentById(imageId);\n        segment.changePosition(newPosition);\n    }\n    getImageSegmentById(imageId) {\n        return this.segments.get(imageId);\n    }\n    getImagesByVideoId(videoId) {\n        const segmentIds = this.segmentsByVideo.get(videoId);\n        if (segmentIds == null)\n            return [];\n        return segmentIds.map(segmentId => {\n            const segment = this.segments.get(segmentId);\n            return segment.getInfo();\n        });\n    }\n}\nclass FilterSegments {\n    filtersByVideoId = new Map();\n    setDefaultFilter(videoId) {\n        this.filtersByVideoId.set(videoId, 'none');\n    }\n    setFilter(videoId, newFilter) {\n        this.filtersByVideoId.set(videoId, newFilter);\n    }\n    getFilterByVideoId(videoId) {\n        return this.filtersByVideoId.get(videoId);\n    }\n}\nclass AudioSegment {\n    media;\n    originalInfo;\n    id;\n    chunksWorker;\n    decoder;\n    frameChannel;\n    constructor({ id, media }) {\n        this.id = id;\n        this.media = media;\n        this.decoder = this.media.audioDecoder;\n        this.frameChannel = this.media.onAudioFrames.bind(this.media);\n        this.originalInfo = this.media.audioInfo;\n    }\n    async startProcessGettingChunks() {\n        const chunks = await this.media.retrieveAudioChunks();\n        this.chunksWorker = new ChunksWorker(chunks);\n        return this;\n    }\n    getInfo() {\n        return this.originalInfo;\n    }\n    getEngine() {\n        return {\n            decoder: this.decoder,\n            chunksWorker: this.chunksWorker,\n            frameChannel: this.frameChannel.bind(this),\n        };\n    }\n}\nclass AudioSegments {\n    segmentsByVideoId = new Map();\n    async create(videoId, media) {\n        const id = (0,_libs_generateId__WEBPACK_IMPORTED_MODULE_1__.generateId)();\n        const audioSegment = await new AudioSegment({\n            id,\n            media,\n        }).startProcessGettingChunks();\n        this.segmentsByVideoId.set(videoId, audioSegment);\n    }\n    getAudioSegmentByVideoId(videoId) {\n        return this.segmentsByVideoId.get(videoId);\n    }\n}\nclass Segments {\n    storage;\n    emitter;\n    videoSegments;\n    audioSegments;\n    imageSegments;\n    filterSegments;\n    displayOrder = [];\n    constructor(storage) {\n        this.storage = storage;\n        this.emitter = new _core_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.videoSegments = new VideoSegments();\n        this.audioSegments = new AudioSegments();\n        this.imageSegments = new ImageSegments();\n        this.filterSegments = new FilterSegments();\n    }\n    async parseMediaSegment(mediaBuffer) {\n        const createdMedia = await this.storage.addMediaToStorage(mediaBuffer);\n        const videoSegmentId = await this.createVideoSegment(createdMedia);\n        await this.createAudioSegment(videoSegmentId, createdMedia);\n        this.increasingOrderSizeAfterAddingVideo(videoSegmentId);\n    }\n    async createVideoSegment(media) {\n        const videoSegmentInfo = await this.videoSegments.create(media);\n        this.filterSegments.setDefaultFilter(videoSegmentInfo.id);\n        this.emitter.emit('video-has-been-added', videoSegmentInfo);\n        return videoSegmentInfo.id;\n    }\n    /**/\n    async createAudioSegment(videoId, media) {\n        await this.audioSegments.create(videoId, media);\n    }\n    /**/\n    async createImageSegment(relatedVideoId, imageBlob) {\n        const createdImage = await this.storage.addImageToStorage(imageBlob);\n        const imageId = this.imageSegments.createImageSegment(relatedVideoId, createdImage.image);\n        this.emitter.emit('image-has-been-added', imageId);\n    }\n    /**/\n    createFilterSegment(videoId) {\n        this.filterSegments.setDefaultFilter(videoId);\n    }\n    /*\n        Причина: изменение видимости состояния одного из сегментов\n    */\n    changeDisplayOrder(videoId) {\n        const { order, timePositions } = this.videoSegments.updateVisibilityStateAndGetUpdatedOrder(videoId);\n        this.displayOrder = order;\n        this.emitter.emit('order-has-been-changed', this.displayOrder);\n        this.emitter.emit('time-position-updated', timePositions);\n    }\n    increasingOrderSizeAfterAddingVideo(videoId) {\n        this.displayOrder.push(videoId);\n        this.emitter.emit('order-has-been-changed', this.displayOrder);\n    }\n    /*\n     */\n    changeImagePosition(imageId, newPosition) {\n        this.imageSegments.changePosition(imageId, newPosition);\n        this.emitter.emit('image-position-has-been-changed');\n    }\n    changeVideoSegmentFilter(videoId, newFilter) {\n        this.filterSegments.setFilter(videoId, newFilter);\n        this.emitter.emit('filter-has-been-changed');\n    }\n    getDisplayOrder() {\n        return this.displayOrder;\n    }\n    getVideoSegmentById(videoId) {\n        return this.videoSegments.getSegmentById(videoId);\n    }\n    getAudioSegmentById(videoId) {\n        return this.audioSegments.getAudioSegmentByVideoId(videoId);\n    }\n    getImageSegmentsByVideoId(videoId) {\n        return this.imageSegments.getImagesByVideoId(videoId);\n    }\n    getFilterByVideoId(videoId) {\n        return this.filterSegments.getFilterByVideoId(videoId);\n    }\n    /**/\n    onVideoAdded(callback) {\n        this.emitter.on('video-has-been-added', callback);\n    }\n    onImageAdded(callback) {\n        this.emitter.on('image-has-been-added', callback);\n    }\n    onOrderChanged(callback) {\n        this.emitter.on('order-has-been-changed', callback);\n    }\n    onImagePositionChange(callback) {\n        this.emitter.on('image-position-has-been-changed', callback);\n    }\n    onFilterChange(callback) {\n        this.emitter.on('filter-has-been-changed', callback);\n    }\n    onTimePositionUpdated(callback) {\n        this.emitter.on('time-position-updated', callback);\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Segments/Segments.ts?");

/***/ }),

/***/ "./src/core/engine/Segments/index.ts":
/*!*******************************************!*\
  !*** ./src/core/engine/Segments/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageSegment: () => (/* reexport safe */ _Segments__WEBPACK_IMPORTED_MODULE_0__.ImageSegment),\n/* harmony export */   Segments: () => (/* reexport safe */ _Segments__WEBPACK_IMPORTED_MODULE_0__.Segments),\n/* harmony export */   VideoSegment: () => (/* reexport safe */ _Segments__WEBPACK_IMPORTED_MODULE_0__.VideoSegment),\n/* harmony export */   VideoSegments: () => (/* reexport safe */ _Segments__WEBPACK_IMPORTED_MODULE_0__.VideoSegments)\n/* harmony export */ });\n/* harmony import */ var _Segments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Segments */ \"./src/core/engine/Segments/Segments.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/Segments/index.ts?");

/***/ }),

/***/ "./src/core/engine/worker.ts":
/*!***********************************!*\
  !*** ./src/core/engine/worker.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Preview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Preview */ \"./src/core/engine/Preview/index.ts\");\n/* harmony import */ var _Segments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Segments */ \"./src/core/engine/Segments/index.ts\");\n/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Engine */ \"./src/core/engine/Engine.ts\");\n/* harmony import */ var _builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../builder */ \"./src/core/builder/index.ts\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../storage */ \"./src/core/storage/index.ts\");\n\n\n\n\n\nconst previewCanvas = new _Preview__WEBPACK_IMPORTED_MODULE_0__.PreviewCanvas();\nconst storage = new _storage__WEBPACK_IMPORTED_MODULE_4__.Storage();\nconst segments = new _Segments__WEBPACK_IMPORTED_MODULE_1__.Segments(storage);\nconst builder = new _builder__WEBPACK_IMPORTED_MODULE_3__.Builder(segments);\nconst engine = new _Engine__WEBPACK_IMPORTED_MODULE_2__.Engine({\n    canvas: previewCanvas,\n    segments,\n});\nsegments.onVideoAdded(data => {\n    globalThis.postMessage({ type: 'RENDER_VIDEO_FRAGMENT', payload: data });\n});\nsegments.onImageAdded(data => {\n    globalThis.postMessage({ type: 'RENDER_IMAGE_FRAGMENT', payload: { id: data } });\n});\nsegments.onTimePositionUpdated(data => {\n    console.log(data);\n    globalThis.postMessage({ type: 'RECALCULATE_TIME', payload: { times: data } });\n});\nbuilder.onFinish(buffer => {\n    console.log('buffer', buffer);\n    globalThis.postMessage({ type: 'FINISH', payload: { buffer } });\n});\nglobalThis.onmessage = async function (event) {\n    const { type, payload } = event.data;\n    switch (type) {\n        case 'INITIALIZATION': {\n            console.log('INITIALIZATION');\n            previewCanvas.linkTo(payload.canvas);\n            break;\n        }\n        case 'ADD_VIDEO': {\n            console.log('ADD_VIDEO', payload);\n            segments.parseMediaSegment(payload.buffer);\n            break;\n        }\n        case 'ADD_IMAGE': {\n            console.log('ADD_IMAGE', payload);\n            segments.createImageSegment(payload.videoId, payload.blob);\n            break;\n        }\n        case 'CHANGE_IMAGE_POSITION': {\n            console.log('CHANGE_IMAGE_POSITION', payload);\n            segments.changeImagePosition(payload.imageId, payload.position);\n            break;\n        }\n        case 'PLAY': {\n            console.log('PLAY');\n            engine.start();\n            break;\n        }\n        case 'PAUSE': {\n            console.log('PAUSE');\n            engine.pause();\n            break;\n        }\n        case 'SWITCH_VISIBILITY_STATE': {\n            console.log('SWITCH_VISIBILITY_STATE', payload);\n            segments.changeDisplayOrder(payload.videoId);\n            break;\n        }\n        case 'APPLY_FILTER_TO_VIDEO': {\n            console.log('APPLY_FILTER_TO_VIDEO', payload);\n            segments.changeVideoSegmentFilter(payload.videoId, payload.filter);\n            break;\n        }\n        case 'GET_PREVIEW_FRAME_FROM_SELECTED_VIDEO': {\n            console.log('GET_PREVIEW_FRAME_FROM_SELECTED_VIDEO', payload);\n            engine.showPreview(payload.videoId, payload.timestamp);\n            break;\n        }\n        case 'EXPORT': {\n            console.log('EXPORT', payload);\n            builder.configure(payload.quality);\n            break;\n        }\n        default:\n            break;\n    }\n};\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/engine/worker.ts?");

/***/ }),

/***/ "./src/core/muxer/Muxer.ts":
/*!*********************************!*\
  !*** ./src/core/muxer/Muxer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Muxer: () => (/* binding */ Muxer)\n/* harmony export */ });\n/* harmony import */ var mp4_muxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mp4-muxer */ \"./node_modules/mp4-muxer/build/mp4-muxer.mjs\");\n\nclass Muxer {\n    muxer;\n    constructor(options) {\n        this.muxer = new mp4_muxer__WEBPACK_IMPORTED_MODULE_0__.Muxer({\n            target: new mp4_muxer__WEBPACK_IMPORTED_MODULE_0__.ArrayBufferTarget(),\n            video: {\n                codec: 'avc',\n                width: options.width,\n                height: options.height,\n            },\n            // audio: {\n            //     codec: 'opus',\n            //     sampleRate: 48000,\n            //     numberOfChannels: 2,\n            // },\n            // firstTimestampBehavior: 'offset',\n        });\n    }\n    addVideoChunk(chunk, meta) {\n        this.muxer.addVideoChunk(chunk, meta);\n    }\n    addAudioChunk(chunk, meta, timestamp) {\n        this.muxer.addAudioChunk(chunk, meta);\n    }\n    finish() {\n        this.muxer.finalize();\n        return this.muxer.target.buffer;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/muxer/Muxer.ts?");

/***/ }),

/***/ "./src/core/muxer/index.ts":
/*!*********************************!*\
  !*** ./src/core/muxer/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Muxer: () => (/* reexport safe */ _Muxer__WEBPACK_IMPORTED_MODULE_0__.Muxer)\n/* harmony export */ });\n/* harmony import */ var _Muxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Muxer */ \"./src/core/muxer/Muxer.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/muxer/index.ts?");

/***/ }),

/***/ "./src/core/storage/Storage.ts":
/*!*************************************!*\
  !*** ./src/core/storage/Storage.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Storage: () => (/* binding */ Storage)\n/* harmony export */ });\n/* harmony import */ var _libs_generateId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/libs/generateId */ \"./src/libs/generateId.ts\");\n/* harmony import */ var _units_MediaStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./units/MediaStorage */ \"./src/core/storage/units/MediaStorage.ts\");\n\n\nclass ImageStorage {\n    imageBlob;\n    imageBitmap;\n    constructor(blob) {\n        this.imageBlob = blob;\n    }\n    async create() {\n        this.imageBitmap = await createImageBitmap(this.imageBlob);\n        return this;\n    }\n    get image() {\n        return this.imageBitmap;\n    }\n}\nclass Storage {\n    media = new Map();\n    images = new Map();\n    async addMediaToStorage(mediaBuffer) {\n        const media = await new _units_MediaStorage__WEBPACK_IMPORTED_MODULE_1__.MediaStorage(mediaBuffer).initialization();\n        this.media.set((0,_libs_generateId__WEBPACK_IMPORTED_MODULE_0__.generateId)(), media);\n        return media;\n    }\n    async addImageToStorage(blob) {\n        const imageStorage = await new ImageStorage(blob).create();\n        this.images.set((0,_libs_generateId__WEBPACK_IMPORTED_MODULE_0__.generateId)(), imageStorage);\n        return imageStorage;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/storage/Storage.ts?");

/***/ }),

/***/ "./src/core/storage/index.ts":
/*!***********************************!*\
  !*** ./src/core/storage/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Storage: () => (/* reexport safe */ _Storage__WEBPACK_IMPORTED_MODULE_0__.Storage)\n/* harmony export */ });\n/* harmony import */ var _Storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Storage */ \"./src/core/storage/Storage.ts\");\n\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/storage/index.ts?");

/***/ }),

/***/ "./src/core/storage/units/MediaStorage.ts":
/*!************************************************!*\
  !*** ./src/core/storage/units/MediaStorage.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaStorage: () => (/* binding */ MediaStorage)\n/* harmony export */ });\n/* harmony import */ var _core_decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/decoder */ \"./src/core/decoder/index.ts\");\n\nclass MediaStorage {\n    decoder;\n    video;\n    audio;\n    onVideoFrames;\n    onAudioFrames;\n    constructor(buffer) {\n        this.decoder = new _core_decoder__WEBPACK_IMPORTED_MODULE_0__.Decoder(buffer);\n        this.onVideoFrames = this.decoder.onVideoFrames.bind(this.decoder);\n        this.onAudioFrames = this.decoder.onAudioFrames.bind(this.decoder);\n    }\n    async initialization() {\n        await this.retrieveVideoAudioInfo();\n        return this;\n    }\n    async retrieveVideoAudioInfo() {\n        const media = await this.decoder.setupMedia();\n        this.video = media.video;\n        this.audio = media.audio;\n        return media;\n    }\n    async retrieveVideoChunks() {\n        return await this.decoder.getReadyVideoChunks();\n    }\n    async retrieveAudioChunks() {\n        return await this.decoder.getReadyAudioChunks();\n    }\n    get videoDecoder() {\n        return this.decoder.getVideoDecoder();\n    }\n    get audioDecoder() {\n        return this.decoder.getAudioDecoder();\n    }\n    get videoInfo() {\n        return this.video;\n    }\n    get audioInfo() {\n        return this.audio;\n    }\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/core/storage/units/MediaStorage.ts?");

/***/ }),

/***/ "./src/libs/generateId.ts":
/*!********************************!*\
  !*** ./src/libs/generateId.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateId: () => (/* binding */ generateId)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n\nfunction generateId() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n}\n\n\n//# sourceURL=webpack://@dream-team-horns-and-hooves/template-project/./src/libs/generateId.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_mp4box_dist_mp4box_all_js-node_modules_uuid_dist_esm-browser_v4_js-node_-f52800"], () => (__webpack_require__("./src/core/engine/worker.ts")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"src_core_engine_worker_ts": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_dream_team_horns_and_hooves_template_project"] = self["webpackChunk_dream_team_horns_and_hooves_template_project"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_mp4box_dist_mp4box_all_js-node_modules_uuid_dist_esm-browser_v4_js-node_-f52800").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;